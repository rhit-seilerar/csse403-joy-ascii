DEFINE
    gif_get_header == 0 at ;
    gif_get_lsd == 1 at ;
    gif_get_gct == 2 at ;
    gif_get_signature == gif_get_header 0 at ["GIF87a" "GIF89a"] swap indexof ;
    gif_get_lsd_flags == gif_get_lsd 2 at ;
    gif_gct_exists == gif_get_lsd_flags 0 at ;
    gif_get_gct_size == [gif_gct_exists] [gif_get_lsd_flags 3 at] [pop 0] ifte ;
    
    gif_get_id == 0 at ;
    gif_get_lct == 1 at ;
    gif_get_lzw == 2 at ;
    gif_get_lzw_min == gif_get_lzw 0 at ;
    gif_get_lzw_size == gif_get_lzw 1 at ;
    gif_get_code_table == 3 at ;
    gif_get_indexes == 4 at ;
    gif_get_id_flags == gif_get_id 4 at ;
    gif_lct_exists == gif_get_id_flags 0 at ;
    gif_get_lct_size == [gif_lct_exists] [gif_get_id_flags 4 at] [pop 0] ifte ;

    (* gif_validate : [Gif..] Getter Values Message -> [Gif..] *)
    gif_validate == [pop rollup i has] [pop] [putchars 1 quit] ifte pop2 ;

    (* File [] -> File [GifHeader] *)
    gif_read_header ==
        swap
        [
            [6 read_chars] (* Signature & Version *)
        ] [i] map
        rolldown arrrev cons arrrev ;

    (* File [GifHeader] -> File [GifHeader GifLogicalScreenDescriptor] *)
    gif_read_logical_screen_descriptor ==
        swap
        [
            [read_short] (* Canvas Width *)
            [read_short] (* Canvas Height *)
            [read_byte []
                [8 div 1 + 2 swap pow trunc] dip cons  (* Global Color Table Size *)
                [2 div 1 =] dip cons                   (* Sort Flag *)
                [8 div 1 + 2 swap pow trunc] dip cons  (* Color Resolution *)
                [2 div 1 =] dip cons                   (* Global Color Table Flag *)
                popd
            ]
            [read_byte] (* Background Color Index *)
            [read_byte] (* Pixel Aspect Ratio *)
        ] [i] map
        rolldown arrrev cons arrrev ;

    (* File [GifHeader GifLSD] -> File [GifHeader GifLSD GifGCT] *)
    gif_read_global_color_table ==
        dup gif_get_gct_size swapd [] swap
        [[dup 3 fread pack_rgb] dip cons] times arrrev
        rolldown arrrev cons arrrev ;

    (* File Handler -> File *)
    gif_read_sub_blocks == swap read_byte [0 !=] [rolldown dup [i] dip swap read_byte] while swapd pop2 ;
    
    (* Gif Image File Size -> Gif Image File *)
    gif_skip_sub_block == dupd fread pop ;

    gif_read_extension == read_byte pop [gif_skip_sub_block] gif_read_sub_blocks ;
    
    gif_read_image_descriptor ==
        swap [
            [read_short] (* Image Left Position *)
            [read_short] (* Image Top Position *)
            [read_short] (* Image Width *)
            [read_short] (* Image Height *)
            [read_byte []
                [8 div 1 + 2 swap pow trunc] dip cons  (* Local Color Table Size *)
                [4 div] dip cons                       (* Reserved *)
                [2 div 1 =] dip cons                   (* Sort Flag *)
                [2 div 1 =] dip cons                   (* Interlace Flag *)
                [2 div 1 =] dip cons                   (* Local Color Table Flag *)
                popd
            ]
        ] [i] map
        rolldown arrrev cons arrrev ;

    (* [Gif..] File [Image..] *)
    gif_read_local_color_table ==
        dup gif_get_lct_size swapd [] swap
        [[dup 3 fread pack_rgb] dip cons] times arrrev
        rolldown arrrev cons arrrev ;

    (* [Gif..] [Image..] -> [Gif..] [Image..] [Table..] *)
    gif_get_color_table ==
        [gif_lct_exists]
        [dup gif_get_lct]
        [[
            [gif_gct_exists]
            [dup gif_get_gct]
            [dup gif_get_gct_size [] swap [0 swons] times]
            ifte
        ] dip swap] ifte ;

    (* [Gif..] [Image..] -> [Gif..] [Image..] [CodeTable..] *)
    gif_make_code_table ==
        gif_get_color_table arrrev
        [dup gif_get_lzw_min] dip dup [size -] dip swap ["N" swons] times "CC" swons "EOI" swons arrrev
        ;

    (* [Gif..] [Image..] -> [Gif.. [Images.. Image]] *)
    gif_add_image == [uncons uncons uncons uncons arrrev] dip swons arrrev cons cons cons cons ;

    (* Stream Thresh Acc *)
    stream_partial_read ==
        [unswonsd] dip swapd   (* Extract avail : Stream Thresh Avail Acc *)
        [pop <]
        [                              (* Partial remove from stream : Stream Thresh Avail Acc   *)
            [dupd swap /] dip          (* Reduce avail               : Stream Thresh Avail Acc   *)
            swap [dup *] dip           (* Shift accumulator          : Stream Thresh Acc Avail   *)
            [[unswonsd div] dip] dip   (* Split byte                 : Stream Quot Rem Acc Avail *)
            [+] dip                    (* Accumulate partial         : Stream Quot Acc Avail     *)
            swap [swonsd swons] dip    (* Update stream              : Stream Acc                *)
            0 swap                     (* Restore thresh             : Stream Thresh Acc         *)
        ]
        [                             (* Full remove from stream : Stream Thresh Avail Acc *)
            dupd *                    (* Shift accumulator       : Stream Thresh Avail Acc *)
            [/] dip                   (* Reduce threshold        : Stream Thresh Acc       *)
            rolldown uncons [+] dip   (* Accumulate byte         : Thresh Acc Stream       *)
            256 swons rollup          (* Reset avail marker      : Stream Thresh Acc       *)
        ]
        ifte ;

    (* Stream Thresh -> Stream Acc *)
    stream_read == 0 [pop 0 !=] [stream_partial_read] while popd ;

    (* Image Stream -> Image Stream Code *)
    gif_next_code ==
        [dup gif_get_lzw_size] dip swap     (* Get thresh          : Image Stream Thresh   *)
        stream_read                         (* Read the next code  : Image Stream Code     *)
        rolldown [gif_get_lzw_size 1 - =]   (* If code == lzw size : Stream Code Image     *)
            [ 2 1 [2 *] member_apply ]      (* Then increment lzw  : Stream Code Image     *)
            [] ifte
        rollup ;                            (* Restore stack order : Image Stream Code     *)

    (* Gif Image -> Gif Image *)
    gif_handle_clear_code ==
        gif_make_code_table 3 replace
        dup gif_get_lzw_min dup 2 * [] cons cons 2 replace ;

    (* Gif Image Stream -> Gif Image *)
    gif_lzw_decode ==
        [gif_handle_clear_code] dip
        gif_next_code
        pop pop ;

    gif_read_image == []
        gif_read_image_descriptor                                     (* 0: Image Descriptor  *)
        gif_read_local_color_table                                    (* 1: Local Color Table *)
        swap read_byte 2 swap pow trunc 0 [] cons cons swapd append   (* 2: LZW Min Size      *)
        [] append                                                     (* 3: Code Table        *)
        [] append                                                     (* 4: Pixels *)
        [] rolldown [dupd fread swap [concat] dip] gif_read_sub_blocks
        [256 swons gif_lzw_decode] dip
        ;

    read_gif == []
        gif_read_header
        [gif_get_signature] [0 1] "Unsupported gif format" gif_validate 
        gif_read_logical_screen_descriptor
        gif_read_global_color_table
        arrrev [] swons arrrev
        
        swap read_byte [59 !=] [[
            [[33 =] pop gif_read_extension ]
            [[44 =] pop gif_read_image [3 member_append] dip]
            ["Unsupported GIF block\n" putchars 1 exit]
        ] cond read_byte] while pop
        
        swap
        ;

    gif_images_to_pixels == pop [[0 0] [0 0]] ;

    (* parse_gif P -> [[I ..] ..] *)
    parse_gif ==
        read_gif
        gif_images_to_pixels
        ;
.
