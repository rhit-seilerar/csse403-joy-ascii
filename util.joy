LIBRA
    dupdd == [dupd] dip ;
    dup2 == dupd dup swapd ;
    pop2 == pop pop ;
    popd2 == [pop pop] dip ;
    dip2 == swap [dip] dip ;
    pstack == stack put ;

    (* indexof: Agg Elem -> Index *)
    indexof == -1 rotate -1 rollup
        [null not]
        [
            [1 +] dip2 uncons [dupd =] dip swap
            [[swapd] dip pop ""] [] branch
        ]
        while pop pop pop ;

    arrrev == [] [swons] swapd step ;
    strrev == "" [swons] swapd step ;

    (* Takes a string and a list of cases [string program..]. If the input matches a case, runs the program with the string as input. The first case has no string and is default. *)
    (* strcase: S [..[S P]..] -> S P i *)
    strcase == uncons swapd [first =] filter [null] [pop swons] [popd popd first] ifte i;

    (* strsplit: Agg Elem -> Agg1 Agg2 *)
    (* Each time Elem is encountered, swap the accumuator. *)
    strsplit ==
        "" rotate dup
        [null not]
        [
            pop uncons [dup2 =] dip swap
            [popd ""]
            [[swap swonsd] dip dup]
            branch
        ]
        while pop popd swap strrev ;

    (* pack_rgba [R G B A] -> I *)
    (* Pops [R G B A] (ints from 0-255) off the stack, outputs a packed int *)
    pack_one == unswonsd 256 * + ;
    pack_rgba == 0 4 [pack_one] times popd ;

    (* unpack_rgba I -> [R G B A] *)
    (* Pops a packed int from the stack, outputs [R G B A] *)
    unpack_one == 256 div swap swonsd ;
    unpack_rgba == [] swap 4 [unpack_one] times pop ;
    
    (* Pack four bytes into a little-endian int *)
    pack_le2 == arrrev 0 2 [pack_one] times popd ;
    pack_le4 == arrrev 0 4 [pack_one] times popd ;

    read_chars == dupd fread "" swap [chr swons] step strrev ;
    read_short == 2 fread pack_le2 ;
    read_int == 4 fread pack_le4 ;
.
